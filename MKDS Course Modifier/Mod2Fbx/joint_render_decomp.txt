void __thiscall Joint::render(Joint *this, struct Graphics *gfx)
{
  struct Matrix4f *animMatrix; // eax
float v3; // eax
struct Vector3f *v4; // [esp-4h] [ebp-26Ch]
struct Vector3f *v6; // [esp-4h] [ebp-26Ch]
Vector3f* v8; // [esp+4Ch] [ebp-21Ch]
Vector3f* v9; // [esp+54h] [ebp-214h]
Vector3f* v10; // [esp+5Ch] [ebp-20Ch]
Vector3f* v11; // [esp+64h] [ebp-204h]
Vector3f* normals; // [esp+6Ch] [ebp-1FCh]
int m; // [esp+194h] [ebp-D4h]
Vector2f* texCoordIterator; // [esp+198h] [ebp-D0h]
int* nrmIdx; // [esp+19Ch] [ebp-CCh]
int* mtxIdx; // [esp+1A0h] [ebp-C8h]
int* vtxIdx; // [esp+1A4h] [ebp-C4h]
Vector2f* texIterator; // [esp+1A8h] [ebp-C0h]
Vector3f* nrmIterator; // [esp+1ACh] [ebp-BCh] MAPDST
Vector3f* vtxIterator; // [esp+1B0h] [ebp-B8h]
FaceNode* curFaceNode; // [esp+1B4h] [ebp-B4h]
int l; // [esp+1BCh] [ebp-ACh]
DispList* face; // [esp+1C0h] [ebp-A8h]
int normalIdxOpt; // [esp+1C4h] [ebp-A4h]
Vector2f* texCoords; // [esp+1CCh] [ebp-9Ch]
Vector3f* vertices; // [esp+1D0h] [ebp-98h]
VtxMatrix* vtxMtx; // [esp+1D4h] [ebp-94h]
int vtxGrpIdx; // [esp+1D8h] [ebp-90h]
int k; // [esp+1DCh] [ebp-8Ch]
MtxGroup* mtxGroup; // [esp+1E0h] [ebp-88h]
int j; // [esp+1E4h] [ebp-84h]
Mesh* matPolyMesh; // [esp+1E8h] [ebp-80h]
Joint::MatPoly* i; // [esp+1ECh] [ebp-7Ch]
int matCount; // [esp+1F0h] [ebp-78h]
struct Matrix4f *animMatrices[10]; // [esp+1F4h] [ebp-74h]

if (this->m_showJoint) {
  matCount = 0;
  for (i = this->m_matpolys.m_child; i; i = i->m_next) {
    matPolyMesh = i->m_mesh;
    ++matCount;
    if ((gfx->dword8 & i->m_material->m_flags) != 0) {
      // name is derived from the PPC version
      gfx->vtbl->setMaterial(gfx, i->m_material);
      for (j = 0; j < matPolyMesh->m_mtxGroupCount; ++j) {
        mtxGroup = &matPolyMesh->m_groups[j];
        if (!mtxGroup->m_dependencyCount)
          animMatrices[0] = &Matrix4f::ident;
        for (k = 0; k < mtxGroup->m_dependencyCount; ++k) {
          vtxGrpIdx = mtxGroup->m_deps[k];
          if (vtxGrpIdx != -1) {
            vtxMtx = &this->m_shape->m_vtxMatrix[vtxGrpIdx];
            if (this->m_shape->m_currentAnims->m_state) {
              if (vtxMtx->m_partiallyWeighted)
                animMatrix = BaseShape::getAnimMatrix(this->m_shape, vtxMtx->m_index);
              else
                animMatrix = BaseShape::getAnimMatrix(this->m_shape, vtxMtx->m_index + this->m_shape->m_jointCount);
              animMatrices[k] = animMatrix;
            } else {
              animMatrices[k] = &this->m_shape->m_joints[vtxMtx->m_index].m_animMatrix;
            }
          }
        }
        vertices = this->m_shape->m_vertices;
        texCoords = this->m_shape->m_texCoords[0];
        // vcd & 0x10000 == use NBT (normal binormal tangent)
        // which is different to just using normal (3 : 1)
        if ((matPolyMesh->m_vcd & 0x10000) != 0)
          normals = this->m_shape->m_nbt;
        else
          normals = this->m_shape->m_normals;
        normalIdxOpt = (matPolyMesh->m_vcd & 0x10000) != 0 ? 3 : 1;
        face = mtxGroup->m_dispLists;
        for (l = 0; l < mtxGroup->m_dispListCount; ++l) {
          gfx->vtbl->setCullFront(gfx, gfx->dword338 ^ face->m_flags & 3);
          for (curFaceNode = face->m_face.m_child; curFaceNode; curFaceNode = curFaceNode->m_next) {
            vtxIterator = gJointVtxIterator;
            nrmIterator = gJointNrmIterator;
            texIterator = gJointTexIterator;
            vtxIdx = curFaceNode->m_vtxIdx;
            mtxIdx = curFaceNode->m_mtxIdx;
            nrmIdx = curFaceNode->m_nrmIdx;
            texCoordIterator = curFaceNode->m_texcoords[0];
            if (curFaceNode->m_faceCount > 511)
              Shape_Print("too many vertices!!\n");
            for (m = 0; m < curFaceNode->m_faceCount; ++m) {
              if (mtxIdx) {
                v4 = vtxIterator++;
                v11 = &vertices[*vtxIdx++];
                Vector3f::multMatrixTo(v11, animMatrices[*mtxIdx], v4);
                if (nrmIdx) {
                  ++nrmIterator;
                  v10 = &normals[normalIdxOpt * *nrmIdx++];
                  Vector3f::rotateTo(v10, animMatrices[*mtxIdx], nrmIterator);
                }
                ++mtxIdx;
              } else {
                v6 = vtxIterator++;
                v9 = &vertices[*vtxIdx++];
                Vector3f::multMatrixTo(v9, animMatrices[0], v6);
                if (nrmIdx) {
                  ++nrmIterator;
                  v8 = &normals[normalIdxOpt * *nrmIdx++];
                  Vector3f::rotateTo(v8, animMatrices[0], nrmIterator);
                }
              }
              if (texCoordIterator) {
                v3 = texCoords[LODWORD(texCoordIterator->x)].y;
                texIterator->x = texCoords[LODWORD(texCoordIterator->x)].x;
                texIterator->y = v3;
                ++texIterator;
                texCoordIterator = (texCoordIterator + 4);
              }
            }
            if ((face->m_flags & 0x1000000) != 0)
              gfx->vtbl->drawTriangleStrip(
                gfx,
                gJointVtxIterator,
                curFaceNode->m_nrmIdx != 0 ? gJointNrmIterator : 0,
                curFaceNode->m_texcoords[0] != 0 ? gJointTexIterator : 0,
                curFaceNode->m_faceCount);
            else
              gfx->vtbl->drawTriangleFan(
                gfx,
                gJointVtxIterator,
                curFaceNode->m_nrmIdx != 0 ? gJointNrmIterator : 0,
                curFaceNode->m_texcoords[0] != 0 ? gJointTexIterator : 0,
                curFaceNode->m_faceCount);
          }
          face = (face + 0x74);
        }
      }
    }
  }
  gfx->vtbl->setMaterial(gfx, 0);
}
}